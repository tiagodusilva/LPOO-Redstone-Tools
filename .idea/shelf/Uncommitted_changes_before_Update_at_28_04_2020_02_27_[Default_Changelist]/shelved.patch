Index: src/test/java/com/lpoo/redstonetools/core/utils/PositionTest.java
===================================================================
--- src/test/java/com/lpoo/redstonetools/core/utils/PositionTest.java	(revision 9a3ac3d10859088bf63f7e8e55ddf9cd7c9c7f67)
+++ src/test/java/com/lpoo/redstonetools/core/utils/PositionTest.java	(revision 9a3ac3d10859088bf63f7e8e55ddf9cd7c9c7f67)
@@ -1,22 +0,0 @@
-package com.lpoo.redstonetools.core.utils;
-
-import com.lpoo.redstonetools.model.utils.Position;
-import com.lpoo.redstonetools.model.utils.Side;
-import org.junit.Test;
-import static org.junit.Assert.assertEquals;
-
-public class PositionTest {
-    @Test
-    public void testNeighbour() {
-        Position middle = new Position(1, 1);
-        Position left = new Position(0, 1);
-        Position right = new Position(2, 1);
-        Position up = new Position(1, 0);
-        Position down = new Position(1, 2);
-
-        assertEquals(left, middle.getNeighbour(Side.LEFT));
-        assertEquals(right, middle.getNeighbour(Side.RIGHT));
-        assertEquals(up, middle.getNeighbour(Side.UP));
-        assertEquals(down, middle.getNeighbour(Side.DOWN));
-    }
-}
Index: src/main/java/com/lpoo/redstonetools/view/lanterna/circuit/LanternaCircuitView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.lpoo.redstonetools.view.lanterna.circuit;\r\n\r\nimport com.googlecode.lanterna.TextColor;\r\nimport com.googlecode.lanterna.graphics.TextGraphics;\r\nimport com.googlecode.lanterna.screen.Screen;\r\nimport com.lpoo.redstonetools.model.circuit.Circuit;\r\nimport com.lpoo.redstonetools.model.tile.Tile;\r\nimport com.lpoo.redstonetools.model.utils.Position;\r\nimport com.lpoo.redstonetools.model.utils.Side;\r\nimport com.lpoo.redstonetools.model.utils.TileType;\r\nimport com.lpoo.redstonetools.view.View;\r\nimport com.lpoo.redstonetools.view.lanterna.tile.*;\r\nimport javafx.geometry.Pos;\r\n\r\nimport java.io.IOException;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class LanternaCircuitView extends View<Circuit> {\r\n\r\n    private Screen screen;\r\n    private Map<TileType, LanternaTileView> renderers;\r\n\r\n    private Circuit circuit;\r\n\r\n    private Position selectedTile;\r\n    private Position viewWindow; // Top-left corner of it\r\n\r\n    public LanternaCircuitView(Screen screen, Circuit circuit) {\r\n        this.screen = screen;\r\n        this.circuit = circuit;\r\n        selectedTile = new Position(0, 0);\r\n        viewWindow = new Position(0, 0);\r\n        this.initRenderers();\r\n    }\r\n\r\n    private void initRenderers() {\r\n        renderers = new HashMap<>();\r\n        renderers.put(TileType.NULL, new LanternaNullTileView());\r\n        renderers.put(TileType.WIRE, new LanternaWireTileView());\r\n        renderers.put(TileType.SOURCE, new LanternaConstantSourceTileView());\r\n        renderers.put(TileType.LEVER, new LanternaLeverTileView());\r\n        renderers.put(TileType.REPEATER, new LanternaRepeaterTileView());\r\n    }\r\n\r\n    public Screen getScreen() {\r\n        return screen;\r\n    }\r\n\r\n    public void moveSelectedTile(Side side) {\r\n        Position newPos = selectedTile.getNeighbour(side);\r\n        if (!validHiglightedPosition(newPos))\r\n            return;\r\n        selectedTile = newPos;\r\n        if (!isInsideViewWindow(selectedTile))\r\n            moveViewWindow(side);\r\n    }\r\n\r\n    public void moveViewWindow(Side side) {\r\n        Position newPos = viewWindow.getNeighbour(side);\r\n        System.out.println(viewWindow +\":\"+validViewWindow(viewWindow));\r\n        System.out.println(newPos);\r\n        System.out.println(validViewWindow(newPos));\r\n        if (!validViewWindow(newPos))\r\n            return;\r\n        viewWindow = newPos;\r\n        if (!isInsideViewWindow(selectedTile))\r\n            moveSelectedTile(side);\r\n    }\r\n\r\n    private boolean validHiglightedPosition(Position position) {\r\n        return position.getX() >= 0 &&\r\n                position.getX() < circuit.getWidth() &&\r\n                position.getY() >= 0 &&\r\n                position.getY() < circuit.getHeight();\r\n    }\r\n\r\n    private boolean isInsideViewWindow(Position position) {\r\n        return position.getX() >= viewWindow.getX() &&\r\n                position.getX() < viewWindow.getX() + getColumns() &&\r\n                position.getY() >= viewWindow.getY() &&\r\n                position.getY() < viewWindow.getY() + getRows();\r\n    }\r\n\r\n    private boolean validViewWindow(Position position) {\r\n        return position.getX() + getColumns() > 0 &&\r\n                position.getX() < circuit.getWidth() &&\r\n                position.getY() + getRows() > 0 &&\r\n                position.getY() < circuit.getHeight();\r\n    }\r\n\r\n    private int getColumns() {\r\n        return screen.getTerminalSize().getColumns() / 3;\r\n    }\r\n\r\n    private int getRows() {\r\n        return screen.getTerminalSize().getRows() / 3;\r\n    }\r\n\r\n    @Override\r\n    public void render(Circuit circuit) {\r\n        screen.clear();\r\n        TextGraphics graphics = screen.newTextGraphics();\r\n\r\n        // TODO: Refactor this, x is the top x-coordinate of the circuit\r\n        for (int i = 0, x = viewWindow.getX(); i < getColumns() * 3; i+=3, x++) {\r\n            // TODO: Refactor this, y is the top y-coordinate of the circuit\r\n            for (int j = 0, y = viewWindow.getY(); j < getRows() * 3; j+=3, y++) {\r\n                graphics.setBackgroundColor(TextColor.ANSI.BLACK);\r\n                graphics.setForegroundColor(TextColor.ANSI.WHITE);\r\n                Tile tile = circuit.getTile(x, y);\r\n                renderers.getOrDefault(tile.getType(), new LanternaNullTileView()).render(tile, j, i, graphics);\r\n            }\r\n        }\r\n\r\n        // Render highlighted\r\n        Tile highlighted = circuit.getTile(selectedTile);\r\n        graphics.setBackgroundColor(TextColor.ANSI.MAGENTA);\r\n        renderers.getOrDefault(highlighted.getType(), new LanternaNullTileView()).render(highlighted,\r\n                (selectedTile.getY() - viewWindow.getY()) * 3,\r\n                (selectedTile.getX() - viewWindow.getX()) * 3, graphics);\r\n\r\n        try {\r\n            screen.refresh();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/lpoo/redstonetools/view/lanterna/circuit/LanternaCircuitView.java	(revision 9a3ac3d10859088bf63f7e8e55ddf9cd7c9c7f67)
+++ src/main/java/com/lpoo/redstonetools/view/lanterna/circuit/LanternaCircuitView.java	(date 1588017420871)
@@ -10,7 +10,6 @@
 import com.lpoo.redstonetools.model.utils.TileType;
 import com.lpoo.redstonetools.view.View;
 import com.lpoo.redstonetools.view.lanterna.tile.*;
-import javafx.geometry.Pos;
 
 import java.io.IOException;
 import java.util.HashMap;
Index: src/main/java/com/lpoo/redstonetools/model/circuit/Circuit.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.lpoo.redstonetools.model.circuit;\r\n\r\nimport com.lpoo.redstonetools.model.Model;\r\nimport com.lpoo.redstonetools.model.tile.NullTile;\r\nimport com.lpoo.redstonetools.model.tile.Tile;\r\nimport com.lpoo.redstonetools.model.utils.Position;\r\nimport com.lpoo.redstonetools.model.utils.Power;\r\nimport com.lpoo.redstonetools.model.utils.Side;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n *  <h1>Circuit model class</h1>\r\n *  Circuit is a group of tiles, all the interaction logic of the tiles is handled by the controller\r\n *\r\n * @see com.lpoo.redstonetools.controller.circuit.CircuitController\r\n *\r\n * @author g79\r\n */\r\npublic class Circuit implements Model {\r\n\r\n    /**\r\n     * <h1>Tiles of the circuit</h1>\r\n     * Grid of tiles of the circuit\r\n     *\r\n     * @see Tile\r\n     */\r\n    private Tile[][] tiles;\r\n\r\n    /**\r\n     * <h1>List of circuit source tiles</h1>\r\n     * Source tiles of the circuits, capable of generating power on their own\r\n     */\r\n    private List<Position> sources;\r\n\r\n    /**\r\n     * <h1>Circuit width dimension</h1>\r\n     */\r\n    private int width;\r\n\r\n    /**\r\n     * <h1>Circuit height dimension</h1>\r\n     */\r\n    private int height;\r\n\r\n    /**\r\n     * <h1>Circuit tick</h1>\r\n     * Simulates the update rate of the circuit\r\n     */\r\n    private long tick;\r\n\r\n    /**\r\n     * <h1>Circuit constructor</h1>\r\n     * The grid of tiles is filled with empty tiles\r\n     * It also sets the initial tick value\r\n     * The sources are initially empty\r\n     *\r\n     * @param width     Width of the circuit\r\n     * @param height    Height of the circuit\r\n     */\r\n    public Circuit(int width, int height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.tiles = new Tile[height][width];\r\n\r\n        for (int i = 0; i < this.height; i++) {\r\n            for (int j = 0; j < this.width; j++) {\r\n                this.tiles[i][j] = new NullTile(new Position(j, i));\r\n            }\r\n        }\r\n\r\n        this.sources = new ArrayList<>();\r\n\r\n        this.tick = 0;\r\n    }\r\n\r\n    /**\r\n     * <h1>Gets the value of the circuit width</h1>\r\n     *\r\n     * @return  Circuit width\r\n     */\r\n    public int getWidth() { return width; }\r\n\r\n    /**\r\n     * <h1>Gets the value of the circuit height</h1>\r\n     *\r\n     * @return  Circuit height\r\n     */\r\n    public int getHeight() { return height; }\r\n\r\n    /**\r\n     * <h1>Gets the current tick value of the circuit</h1>\r\n     *\r\n     * @return  Circuit tick value\r\n     */\r\n    public long getTick() { return tick; }\r\n\r\n    /**\r\n     * <h1>Increments the circuit tick</h1>\r\n     *\r\n     * All operations to be done on new ticks are handled by the circuit controller\r\n     *\r\n     * @see com.lpoo.redstonetools.controller.circuit.CircuitController\r\n     */\r\n    public void advanceTick() { tick++; }\r\n\r\n    /**\r\n     * <h1>Gets the list of source tiles</h1>\r\n     *\r\n     * @return  Circuit source tiles\r\n     */\r\n    public List<Position> getSources() { return sources; }\r\n\r\n    /**\r\n     * <h1>Checks validity of a position</h1>\r\n     * Tests if the position given is inside the circuit\r\n     *\r\n     * @param position  Position to be tested\r\n     * @return  true if the position is inside the circuit, false otherwise\r\n     */\r\n    public boolean isInBounds(Position position) {\r\n        return  position.getX() >= 0 &&\r\n                position.getX() < width &&\r\n                position.getY() >= 0 &&\r\n                position.getY() < height;\r\n    }\r\n\r\n    /**\r\n     * <h1>Gets the tile in the specified position of the circuit</h1>\r\n     * Gets the tile in the specified position of the circuit if the position is valid\r\n     * If the position isn't valid, it is returned a new empty tile\r\n     * \r\n     * @see Circuit#isInBounds(Position)\r\n     * @see NullTile\r\n     *\r\n     * @param position  Position of the tile\r\n     * @return  Tile in the position specified if valid, <code>NullTile</code> on invalid position\r\n     */\r\n    public Tile getTile(Position position) {\r\n        if (!isInBounds(position))\r\n            return new NullTile(position);\r\n\r\n        return this.tiles[position.getY()][position.getX()];\r\n    }\r\n\r\n    /**\r\n     * <h1>Gets the tile in the specified position of the circuit</h1>\r\n     * Wrapper of function <code>getTile(Position)</code> to accept two integer values instead of a <code>Position</code> object\r\n     *\r\n     * @see Circuit#getTile(Position)\r\n     * \r\n     * @param x     Position on the horizontal axis\r\n     * @param y     Position on the vertical axis\r\n     * @return  Tile in the position specified if valid, <code>NullTile</code> on invalid position\r\n     */\r\n    public Tile getTile(int x, int y) {\r\n        return getTile(new Position(x, y));\r\n    }\r\n\r\n    /**\r\n     * <h1>Removes a tile from the sources</h1>\r\n     * Auxiliary function to guarantee the integrity of the source tiles\r\n     *\r\n     * @param position  Position of the tile to be removed\r\n     */\r\n    private void safeRemoveTile(Position position) {\r\n        if (getTile(position).isSource())\r\n            sources.remove(position);\r\n    }\r\n\r\n    /**\r\n     * <h1>Adds tile to the circuit</h1>\r\n     * Adds tile to the circuit if tile has a valid position\r\n     * To guarantee integrity it removes the previous tile from the sources if needed\r\n     * If the tile to be added is also a source, then it is added to the list of sources\r\n     * \r\n     * @see Circuit#safeRemoveTile(Position)\r\n     *\r\n     * @param tile  Tile to be added\r\n     * @return  true if the tile was added, false otherwise\r\n     */\r\n    public boolean addTile(Tile tile) {\r\n        if (!isInBounds(tile.getPosition()))\r\n            return false;\r\n\r\n        safeRemoveTile(tile.getPosition());\r\n\r\n        this.tiles[tile.getPosition().getY()][tile.getPosition().getX()] = tile;\r\n        if (tile.isSource())\r\n            this.sources.add(tile.getPosition());\r\n        tile.updateConnections(this);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * <h1>Removes tile from circuit</h1>\r\n     * Removing a tile from the circuit is switching the tile for a empty tile, this is adding a <code>NullTile</code>\r\n     *\r\n     * @see NullTile\r\n     * @see Circuit#addTile(Tile)\r\n     *\r\n     * @param position  Position of the tile to be removed\r\n     */\r\n    public void removeTile(Position position) {\r\n        addTile(new NullTile(position));\r\n    }\r\n\r\n    /**\r\n     * <h1>Get the power level received from the neighbours</h1>\r\n     * Gets the maximum power level received from the neighbour tiles\r\n     *\r\n     * @param position  Position of the tile to check surroundings\r\n     * @return  Maximum power level in the neighbourhood\r\n     */\r\n    public int getSurroundingPower(Position position) {\r\n        int maxPower = Power.getMin();\r\n        for (Side side : Side.values()) {\r\n            Tile tile = getTile(position.getNeighbour(side));\r\n            maxPower = Math.max(maxPower, tile.isWire() ?\r\n                                                tile.getPower(side.opposite()) - 1\r\n                                                : tile.getPower(side.opposite())\r\n                                );\r\n        }\r\n        return maxPower;\r\n    }\r\n\r\n    /**\r\n     * <h1>Get the power level received from the neighbour wires</h1>\r\n     * Gets the maximum power level received from the neighbour wires\r\n     *\r\n     * @param position  Position of the tile to check surroundings\r\n     * @return  Maximum power level in the neighbourhood\r\n     */\r\n    public int getSurroundingWirePower(Position position) {\r\n        int maxPower = Power.getMin();\r\n        for (Side side : Side.values()) {\r\n            Tile tile = getTile(position.getNeighbour(side));\r\n            if (tile.isWire())\r\n                maxPower = Math.max(maxPower, tile.getPower(side.opposite()) - 1);\r\n        }\r\n        return maxPower;\r\n    }\r\n\r\n    /**\r\n     * <h1>Get the power level received from the neighbour non-wire tiles</h1>\r\n     * Gets the maximum power level received from the neighbour non-wire tiles\r\n     *\r\n     * @param position  Position of the tile to check surroundings\r\n     * @return  Maximum power level in the neighbourhood\r\n     */\r\n    public int getSurroundingGatePower(Position position) {\r\n        int maxPower = Power.getMin();\r\n        for (Side side : Side.values()) {\r\n            Tile tile = getTile(position.getNeighbour(side));\r\n            if (!tile.isWire())\r\n                maxPower = Math.max(maxPower, tile.getPower(side.opposite()));\r\n        }\r\n        return maxPower;\r\n    }\r\n\r\n    /**\r\n     * <h1>Tests if tiles can connect</h1>\r\n     * A tile can connect to other if the side of contact of the tiles are output and input or vice-versa\r\n     *\r\n     * @param position  Position of the tile\r\n     * @param side      Side of the neighbour to test with\r\n     * @return  true if the tiles are connectable, false otherwise\r\n     */\r\n    public boolean canTilesConnect(Position position, Side side) {\r\n        Tile a = getTile(position);\r\n        Tile b = getTile(position.getNeighbour(side));\r\n        return (a.acceptsPower(side) && b.outputsPower(side.opposite())) ||\r\n                (a.outputsPower(side) && b.acceptsPower(side.opposite()));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/lpoo/redstonetools/model/circuit/Circuit.java	(revision 9a3ac3d10859088bf63f7e8e55ddf9cd7c9c7f67)
+++ src/main/java/com/lpoo/redstonetools/model/circuit/Circuit.java	(date 1588035141844)
@@ -218,7 +218,7 @@
         for (Side side : Side.values()) {
             Tile tile = getTile(position.getNeighbour(side));
             maxPower = Math.max(maxPower, tile.isWire() ?
-                                                tile.getPower(side.opposite()) - 1
+                                                Power.decrease(tile.getPower(side.opposite()))
                                                 : tile.getPower(side.opposite())
                                 );
         }
@@ -237,7 +237,7 @@
         for (Side side : Side.values()) {
             Tile tile = getTile(position.getNeighbour(side));
             if (tile.isWire())
-                maxPower = Math.max(maxPower, tile.getPower(side.opposite()) - 1);
+                maxPower = Math.max(maxPower, Power.decrease(tile.getPower(side.opposite())));
         }
         return maxPower;
     }
Index: src/test/java/com/lpoo/redstonetools/model/tile/NullTileTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/java/com/lpoo/redstonetools/model/tile/NullTileTest.java	(date 1588037212090)
+++ src/test/java/com/lpoo/redstonetools/model/tile/NullTileTest.java	(date 1588037212090)
@@ -0,0 +1,23 @@
+package com.lpoo.redstonetools.model.tile;
+
+import com.lpoo.redstonetools.model.utils.Position;
+import com.lpoo.redstonetools.model.utils.TileType;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class NullTileTest {
+
+    @Test
+    public void testNullTileConstructor() {
+        Position position = new Position(5, 5);
+        NullTile nullTile = new NullTile(position);
+
+        Assert.assertEquals(position, nullTile.getPosition());
+        Assert.assertEquals("null", nullTile.getName());
+        Assert.assertEquals("", nullTile.getInfo());
+        Assert.assertEquals(TileType.NULL, nullTile.getType());
+    }
+
+
+
+}
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>plugins {\r\n    id 'java'\r\n}\r\n\r\ngroup 'com.lpoo.redstonetools'\r\nversion '1.0-SNAPSHOT'\r\n\r\nsourceCompatibility = 1.8\r\n\r\nrepositories {\r\n    mavenCentral()\r\n}\r\n\r\ndependencies {\r\n    testCompile group: 'junit', name: 'junit', version: '4.12'\r\n    compile group: 'com.googlecode.lanterna', name: 'lanterna', version: '3.0.1'\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- build.gradle	(revision 9a3ac3d10859088bf63f7e8e55ddf9cd7c9c7f67)
+++ build.gradle	(date 1588036585660)
@@ -13,5 +13,6 @@
 
 dependencies {
     testCompile group: 'junit', name: 'junit', version: '4.12'
+    testCompile group: 'org.mockito', name: 'mockito-core', version: '2.25.0'
     compile group: 'com.googlecode.lanterna', name: 'lanterna', version: '3.0.1'
 }
Index: src/test/java/com/lpoo/redstonetools/model/utils/PositionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/java/com/lpoo/redstonetools/model/utils/PositionTest.java	(date 1588037001234)
+++ src/test/java/com/lpoo/redstonetools/model/utils/PositionTest.java	(date 1588037001234)
@@ -0,0 +1,65 @@
+package com.lpoo.redstonetools.model.utils;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class PositionTest {
+
+    @Test
+    public void testPositionConstructor() {
+        Position position = new Position(5, 10);
+        Assert.assertEquals("Position(5, 10)", position.toString());
+    }
+
+    @Test
+    public void testPositionGetters() {
+        Position position = new Position(5, 10);
+        Assert.assertEquals(5, position.getX());
+        Assert.assertEquals(10, position.getY());
+    }
+
+    @Test
+    public void testPositionSetters() {
+        Position position = new Position(5, 10);
+        Assert.assertEquals(5, position.getX());
+        Assert.assertEquals(10, position.getY());
+        position.setX(-5);
+        position.setY(32);
+        Assert.assertEquals(-5, position.getX());
+        Assert.assertEquals(32, position.getY());
+    }
+
+    @Test
+    public void testPositionGetNeighbour() {
+        Position middle = new Position(1, 1);
+        Position left = new Position(0, 1);
+        Position right = new Position(2, 1);
+        Position up = new Position(1, 0);
+        Position down = new Position(1, 2);
+
+        Assert.assertEquals(left, middle.getNeighbour(Side.LEFT));
+        Assert.assertEquals(right, middle.getNeighbour(Side.RIGHT));
+        Assert.assertEquals(up, middle.getNeighbour(Side.UP));
+        Assert.assertEquals(down, middle.getNeighbour(Side.DOWN));
+    }
+
+    @Test
+    public void testPositionEquals() {
+        Position position1 = new Position(5, 5);
+        Position position2 = new Position(5, 5);
+        Position position3 = new Position(5, 4);
+
+        Assert.assertEquals(position1, position2);
+        Assert.assertNotEquals(position1, position3);
+        Assert.assertNotEquals(position2, position3);
+    }
+
+    @Test
+    public void testPositionClone() {
+        Position position = new Position(5, 5);
+        Position clone = position.clone();
+
+        Assert.assertEquals(position, clone);
+        Assert.assertNotSame(position, clone);
+    }
+}
Index: gradle/wrapper/gradle-wrapper.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>distributionBase=GRADLE_USER_HOME\r\ndistributionPath=wrapper/dists\r\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-5.2.1-bin.zip\r\nzipStoreBase=GRADLE_USER_HOME\r\nzipStorePath=wrapper/dists\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>windows-1252
===================================================================
--- gradle/wrapper/gradle-wrapper.properties	(revision 9a3ac3d10859088bf63f7e8e55ddf9cd7c9c7f67)
+++ gradle/wrapper/gradle-wrapper.properties	(date 1587570960573)
@@ -1,5 +1,6 @@
+#Wed Apr 22 15:55:24 BST 2020
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.2.1-all.zip
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.2.1-bin.zip
-zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
Index: src/test/java/com/lpoo/redstonetools/model/utils/SideTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/java/com/lpoo/redstonetools/model/utils/SideTest.java	(date 1588035934772)
+++ src/test/java/com/lpoo/redstonetools/model/utils/SideTest.java	(date 1588035934772)
@@ -0,0 +1,16 @@
+package com.lpoo.redstonetools.model.utils;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class SideTest {
+
+    @Test
+    public void testSideOpposite() {
+        Assert.assertEquals(Side.UP, (Side.DOWN).opposite());
+        Assert.assertEquals(Side.DOWN, (Side.UP).opposite());
+        Assert.assertEquals(Side.LEFT, (Side.RIGHT).opposite());
+        Assert.assertEquals(Side.RIGHT, (Side.LEFT).opposite());
+    }
+
+}
